% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggplotPath.R, R/ggplotPath2.R
\name{ggplotPath}
\alias{ggplotPath}
\title{\code{ggplot} paths}
\usage{
ggplotPath(
  x = "year",
  y,
  group,
  data,
  scaley = 1,
  logy = TRUE,
  ylab,
  legend.position,
  hlines,
  vlines,
  labels,
  fontsize = 10,
  color,
  linetype
)

ggplotPath(
  x = "year",
  y,
  group,
  data,
  scaley = 1,
  logy = TRUE,
  ylab,
  legend.position,
  hlines,
  vlines,
  labels,
  fontsize = 10,
  color,
  linetype
)
}
\arguments{
\item{x}{name of column in \code{data} to pass as \code{x} in
\code{aes(x=.data[[x]], ...)}; default = \code{year}.}

\item{y}{name of column in \code{data} to pass as \code{y} in
\code{aes(y=.data[[y]], ...)}; must be supplied.}

\item{group}{name of grouping variable, i.e., plot a separate line for each
level of \code{group} using \code{aes(group=.data[[group]], ...)}, unless \code{group} is
missing or \code{length(unique(data[, group]))} = 1.}

\item{data}{\code{\link{data.frame}} or \code{\link[tibble:tibble]{tibble::tibble}} with columns \code{x}, \code{y}, and
\code{group}.}

\item{scaley}{factor to divide y by for plotting. Default = 1, but for data
in monetary terms, e.g., for \code{MaddisonData}, \code{y = 'gdppc'} is Gross domestic
product (GDP) per capita in 2011 dollars at purchasing power parity (PPP),
for which we typically want \code{scaley} = 1000.}

\item{logy}{logical: if \code{TRUE}, y axis is on a log scale; default = \code{TRUE}.`}

\item{ylab}{optional character vector of length \code{k} for y axis labels.}

\item{legend.position}{argument passed to \code{\link[ggplot2:theme]{ggplot2::theme}}. If \code{!missing(labels)},
default is no legend. Otherwise, default depends on
\verb{nGps <- length(unique(data[, group]}: If \code{nGps} = 1, there is no legend. If
\code{nGps > 10}, \code{legend.position = 'right'}. In between, \code{legend.position} =
c(.15, .5) = center left. For alternatives, see \code{\link[ggplot2:theme]{ggplot2::theme}}.}

\item{hlines}{list of length \code{k} of numeric vectors (possibly with
attributes), for horizontal lines in panel \code{i}, feeding \code{hlines[[i]]} to
\code{ggplotPath(..., hlines = hlines[[i]])} for panel \code{i = 1:k}.
\verb{color='grey', lty='dotted'} unless \code{color} or \code{colour} and / or \code{lty}
are available as \code{attr(x, ...)}.}

\item{vlines}{numeric vector of locations on the \code{x} axis for vertical lines
using \code{ggplotPath(..., vlines=vlines)} with \verb{color='grey', lty='dotted'}
unless \code{color} or \code{colour} and / or \code{lty} are available as
\code{attr(vlines, ...)}.}

\item{labels}{= \code{\link{data.frame}} with columns \verb{x, y, label, component}, and
optionally \verb{srt, col, size}, where \code{x}, \code{y}, \code{srt}, and \code{size} are are
numeric, \code{label} is character, and \code{col} are acceptable values for \code{color}
in \code{with(labels, annotate('text', x=x, y=y, label = label, srt=srt,  color=col, size=size))}. Defaults for \code{srt}, \code{col}, and \code{size}  are 0,
'black', and 4, respectively. \code{component} is an integer in \code{1:k}.
\code{labelsi = subset(labels, component==i)} is used in
\code{ggplotPath(..., labels=labelsi)} to label panel \code{i = 1:k}.}

\item{fontsize}{for legend and axes labels, used in
`ggplotPath(..., fontsize=fontsize); default = 10.}

\item{color}{for lines, used in
#' \code{ggplotPath(..., color=color[i])} for panel \code{i=1:k}.
present. If present, \code{length(color)} should equal \code{k}.}

\item{linetype}{optional vector of lengtt \code{k}. Default = \code{rep(1, k)}.
see \code{help(ggplotPath)} for options.}

\item{object}{with an associated matrix to be plotted. The following
classes of objects are supported:
\itemize{
\item \code{matrix} or \code{mts} of \code{dim = c(n, k)}, assumed to be \code{k} components
of a state vector at \code{n} points in time, with \code{ggplotPath} called
separately for each of the \code{k} column and returns a \code{ggplot} object
with a separate panel for each column with a shared horizontal axis and
no space between the panels.
\item \code{KFS} (defined in package \code{KFAS}) calls
\code{ggplotPath.matrix(object$a, ...)}.
\item \code{model} (defined in package \code{KFAS}) calls
\code{ggplotPath.matrix(KFAS::KFS(object$a), ...)}. `
}}

\item{time:}{If present, it must be a numeric vector of length equal to the
number of rows of the matrix obtained from \code{object} and fed to \code{ggplotPath}
to create the individual panels of the plot. Default depends on
\code{class(object)}:
\itemize{
\item \code{matrix}: Default \code{time = rownames(object)}.
\item \code{mts}: Default \code{time = time(object)}.
\item \code{KFS} (defined in package \code{KFAS}): Default = \code{rownames} or \code{time}
of \code{object$model$y}.
\item \code{model} (defined in package \code{KFAS}): Default = \code{rownames} or \code{time}
of \code{object$y}.
}}

\item{`scaley`}{= optional numeric vector of the length \code{k} fed individually
as the \code{scaley} argument accompanying the different successive calls to
\code{ggplotPath}. If the matrix obtained from \code{object} has two columns with
names = c('level', 'slope'), then the default for \code{scaley} = c(1000, 100).
Otherwise, default = 1.}

\item{`logy`}{character vector of length \code{k} to control what is plotted in
the individual panels of the plot:
\itemize{
\item \code{exp_log}: Feed \code{exp} of column \code{i} of the matrix to plot to
\code{ggplotPath(..., logy=TRUE)}.
\item \code{log}: Feed column \code{i} of the matrix to plot to
\code{ggplotPath(..., logy=TRUE)}.
\item '': Feed column \code{i} of the matrix to plot to
\code{ggplotPath(..., logy=FALSE)}.
}
Default = \verb{c('exp_log', rep('', k-1)}.}
}
\value{
an object of class \code{\link[ggplot2:ggplot]{ggplot2::ggplot}}, which can be subsequently
edited, and whose \code{\link{print}} method produces the desired plot.

an object of class \code{\link[ggplot2:ggplot]{ggplot2::ggplot}}, which can be subsequently
edited, and whose \code{\link{print}} method produces the desired plot.
}
\description{
\code{ggplotPath} plots \code{y} vs. \code{x} (typically \code{year}) with a separate line for
each group with options for legend placement, horizontal and vertical lines
and labels.

\code{ggplotPath} plots \code{y} vs. \code{x} (typically \code{year}) with a separate line for
each group with options for legend placement, horizontal and vertical lines
and labels.
}
\examples{
str(GBR_USA <- subset(MaddisonData::MaddisonData, ISO \%in\% c('GBR', 'USA')))
GBR_USA1 <- MaddisonData::ggplotPath('year', 'gdppc', 'ISO', GBR_USA, 1000)

GBR_USA1+ggplot2::coord_cartesian(xlim=c(1500, 1850)) # for only 1500-1850 
GBR_USA1+ggplot2::coord_cartesian(xlim=c(1600, 1700), ylim=c(7, 17)) 

# label the lines
ISOll <- data.frame(x=c(1500, 1800), y=c(2.5, 1.7), label=c('GBR', 'USA'), 
              srt=c(0, 30), col=c('red', 'green'), size=c(2, 9))
GBR_USA2 <- ggplotPath('year', 'gdppc', 'ISO', GBR_USA, 1000, 
                    labels=ISOll, fontsize = 20)  
                        
# h, vlines, manual legend only 
Hlines <- c(1,3, 10, 30)
Vlines = c(1849, 1929, 1933, 1939, 1945)
(GBR_USA3 <- ggplotPath('year', 'gdppc', 'ISO', GBR_USA, 1000, 
       ylab='GDP per capita (2011 PPP K$)', 
       legend.position = NULL, hlines=Hlines, vlines=Vlines, labels=ISOll))  

Mat <- cbind(lvl=1:5, vel=rep(1:2, length=5), acc=sin(1:5))
Mat1 <- Mat
rownames(Mat1) <- 1951:1955
MTS <- ts(Mat, 1951)
lbls <- 

# State space / Kalman filtering model for GBR
GBR <- subset(MaddisonData, (ISO=='GBR') & !is.na(gdppc))
EWMA2mdl0 <- function(sigma, n, Data=GBR) {
# y = Z a + e
  Z <- matrix(1:0, 1, 2) 
  stateNames <- c('level', 'slope')
  dimnames(Z) <- list('lnGDPpc', stateNames)
# a = T a + Q eta  
  dYr. <- diff(Data$year)
  dYr <- c(5*max(dYr.), dYr.)
  T2 <- array(1, c(2, 2, n))
  T2[2,1,] <- 0
  T2[1,2,] <- dYr 
  dimnames(T2) <- list(stateNames, stateNames, Data$year)
  T2_ <- T2[, , n, drop=TRUE]
  R2 <- array(1, c(2, 2, n))
  R2[2, 1, ] <- 0 
  R2[1, 2, ] <- dYr 
  dimnames(R2) <- list(stateNames, paste0(stateNames, 'Eta'))
  R2_ <- R2[,,n, drop=TRUE]
  Q2 <- array(0, c(2, 2, nobs) )
  # FOR IRREGULAR TIME SERIES:   
  # chol(Q2[,,i]) = (sqrt(dYr)) sqr(choose(dYr, 2))*sqrt(signma)
  #                 (    0           sqr(dYr)     )
  # so 
  # Q2[,,i] = (         dYr          sqrt(dYr*choose(dYr, 2)))*sigma
  #         = (sqrt(dYr*choose(dYr, 2))       dYr           )  
  # NOTE: choose(1, 2) = 0, so when dYr=1, Q2=diag(2)  
  Q2[1,1,] <- dYr*sigma^2
  Q2[2,2,] <- dYr*sigma^2
  Q2[1,2,] <- sqrt(dYr*choose(dYr, 2))*sigma^2
  Q2[2,1,] <- sqrt(dYr*choose(dYr, 2))*sigma^2
  dimnames(Q2) <- list(stateNames, stateNames, selMadd$year)
  Q2_ <- Q2[,,n, drop=TRUE]
  a1 <- c(level=log(selMadd$gdppc[1]), 
          slope=mean(diff(log(selMadd$gdppc[2:30]))))
#  P1 <- 10  optional
SSMc <- SSMcustom(Z=Z, T=T2, R=R2, Q=Q2, a1=a1, n = n, 
                  state_names = stateNames)
SSMbespoke(SSMc, n)
}






ISOll <- data.frame(x=c(1500, 1800), y=c(2.5, 1.7), label=c('GBR', 'USA'), 
              srt=c(0, 30), col=c('red', 'green'), size=c(2, 9))
GBR_USA2 <- ggplotPath('year', 'gdppc', 'ISO', GBR_USA, 1000, 
                    labels=ISOll, fontsize = 20)  
                        
# h, vlines, manual legend only 
Hlines <- c(1,3, 10, 30)
Vlines = c(1849, 1929, 1933, 1939, 1945)
(GBR_USA3 <- ggplotPath('year', 'gdppc', 'ISO', GBR_USA, 1000, 
       ylab='GDP per capita (2011 PPP K$)', 
       legend.position = NULL, hlines=Hlines, vlines=Vlines, labels=ISOll))  

}
\keyword{plot}
